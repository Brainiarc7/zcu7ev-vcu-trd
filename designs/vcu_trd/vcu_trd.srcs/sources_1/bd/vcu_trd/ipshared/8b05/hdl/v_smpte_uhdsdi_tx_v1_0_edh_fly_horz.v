// (c) Copyright 2002 - 2015 Xilinx, Inc. All rights reserved.
// 
// This file contains confidential and proprietary information
// of Xilinx, Inc. and is protected under U.S. and
// international copyright and other intellectual property
// laws.
// 
// DISCLAIMER
// This disclaimer is not a license and does not grant any
// rights to the materials distributed herewith. Except as
// otherwise provided in a valid license issued to you by
// Xilinx, and to the maximum extent permitted by applicable
// law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// (2) Xilinx shall not be liable (whether in contract or tort,
// including negligence, or under any other theory of
// liability) for any loss or damage of any kind or nature
// related to, arising under or in connection with these
// materials, including for any direct, or any indirect,
// special, incidental, or consequential loss or damage
// (including loss of data, profits, goodwill, or any type of
// loss or damage suffered as a result of any action brought
// by a third party) even if such damage or loss was
// reasonably foreseeable or Xilinx had been advised of the
// possibility of the same.
// 
// CRITICAL APPLICATIONS
// Xilinx products are not designed or intended to be fail-
// safe, or for use in any application requiring fail-safe
// performance, such as life-support or safety devices or
// systems, Class III medical devices, nuclear facilities,
// applications related to the deployment of airbags, or any
// other applications that could lead to death, personal
// injury, or severe property or environmental damage
// (individually and collectively, "Critical
// Applications"). Customer assumes the sole risk and
// liability of any use of Xilinx products in Critical
// Applications, subject only to applicable laws and
// regulations governing limitations on product liability.
// 
// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// PART OF THIS FILE AT ALL TIMES.
// 
// 
//------------------------------------------------------------------------------
/* 
This module implements the horizontal logic for the video flywheel.

The module contains the horizontal counter. This counter keeps track of the
current horizontal position of the video. The module also generates the H 
signal. The H signal is asserted during the inactive portion of each scan line.

This module has the following inputs:

clk: clock input

rst: synchronous reset

ce: clock enable

clr_hcnt: When this input is asserted, the horizontal counter is cleared.

resync_hcnt: When this input is asserted, the horizontal counter is reloaded
with the position of the EAV symbol. This happens during synchronous switches.

std: The video standard input code.

The module generates the following outputs:

hcnt: This is the value of the horizontal counter and indicates the current
horizontal positon of the video.

eav_next: Asserted the clock cycle before it is time for the flywheel to
generate the first word of an EAV symbol.

sav_next: Asserted the clock cycle before it is time for the flywheel to 
generate the first word of an SAV symbol.

h: This is the horizontal blanking bit.

trs_word: A 2-bit code indicating which word of the TRS symbol should be
generated by the flywheel.

fly_trs: Asserted during the first word of a flywheel generated TRS symbol.

fly_eav: Asserted during the XYZ word of a flywheel generated EAV symbol.

fly_sav: Asserted during the XYZ word of a flywheel generated SAV symbol.
*/

`timescale 1ns / 1ps
(* DowngradeIPIdentifiedWarnings="yes" *)
module v_smpte_uhdsdi_tx_v1_0_0_edh_fly_horz #(
    parameter HCNT_WIDTH = 12)
(
    input  wire                     clk,            // clock input
    input  wire                     rst,            // sync reset input
    input  wire                     ce,             // clock enable
    input  wire                     clr_hcnt,       // clears the horizontal counter
    input  wire                     resync_hcnt,    // resynchronized horizontal counter during sync switch
    input  wire [2:0]               std,            // indicates current video standard
    output wire [HCNT_WIDTH-1:0]    hcnt,           // horizontal count
    output wire                     eav_next,       // asserted when next word is first word of EAV symbol
    output wire                     sav_next,       // asserted when next word is first word of SAV symbol
    output reg                      h = 1'b0,       // horizontal blanking bit
    output reg  [1:0]               trs_word = 0,   // indicates which word of the TRS symbol is being generated
    output wire                     fly_trs,        // asserted during first word of a flywheel generated TRS
    output wire                     fly_eav,        // asserted during xyz word of a flywheel generated EAV
    output wire                     fly_sav         // asserted during xyz word of a flywheel generated SAV
);

//-----------------------------------------------------------------------------
// Parameter definitions
//

localparam HCNT_MSB = HCNT_WIDTH - 1;

//
// This group of parameters defines the starting position of the EAV symbol
// for the various supported video standards.
//
localparam EAV_LOC_NTSC_422          = 1440;
localparam EAV_LOC_NTSC_COMPOSITE    = 790;
localparam EAV_LOC_NTSC_422_WIDE     = 1920;
localparam EAV_LOC_NTSC_4444         = 2880;
localparam EAV_LOC_PAL_422           = 1440;
localparam EAV_LOC_PAL_COMPOSITE     = 972;
localparam EAV_LOC_PAL_422_WIDE      = 1920;
localparam EAV_LOC_PAL_4444          = 2880;

//
// This group of parameters defines the starting position of the SAV symbol
// for the various supported video standards.
//
localparam SAV_LOC_NTSC_422          = 1712;
localparam SAV_LOC_NTSC_COMPOSITE    = 790;
localparam SAV_LOC_NTSC_422_WIDE     = 2284;
localparam SAV_LOC_NTSC_4444         = 3428;
localparam SAV_LOC_PAL_422           = 1724;
localparam SAV_LOC_PAL_COMPOSITE     = 972;
localparam SAV_LOC_PAL_422_WIDE      = 2300;
localparam SAV_LOC_PAL_4444          = 3452;

//
// This group of parameters defines the encoding for the video standards output
// code.
//
localparam [2:0]
    NTSC_422        = 3'b000,
    NTSC_INVALID    = 3'b001,
    NTSC_422_WIDE   = 3'b010,
    NTSC_4444       = 3'b011,
    PAL_422         = 3'b100,
    PAL_INVALID     = 3'b101,
    PAL_422_WIDE    = 3'b110,
    PAL_4444        = 3'b111;

//-----------------------------------------------------------------------------
// Signal definitions
//
reg     [HCNT_MSB:0]    hcount = 1;     // horizontal counter
wire                    trs_next;       // TRS symbol starts on next count
reg                     trs = 1'b0;     // internal version of fly_trs signal
reg                     fly_xyz = 1'b0; // asserted during flywheel generated XYZ word
reg     [HCNT_MSB:0]    eav_loc;        // EAV location
reg     [HCNT_MSB:0]    sav_loc;        // SAV location
reg     [HCNT_MSB:0]    resync_val;     // value to load on resync_hcnt

//
// hcount: horizontal counter
//
// The horizontal counter increments every clock cycle to keep track of the
// current horizontal position. If clr_hcnt is asserted by the FSM, hcnt is
// reloaded with a value of 1. A value of 1 is used because of the latency
// involved in detected the TRS symbol and deciding whether to clear hcnt or
// not. If resync_hcnt is asserted, the horizontal coutner is loaded with
// resync_val, a value derived from the EAV position. This happens during
// synchronous switches. 
//
always @ (posedge clk)
    if (ce)
    begin
        if (rst)
            hcount <= 1;
        else if (resync_hcnt)
            hcount <= resync_val;
        else if (clr_hcnt)
            hcount <= 1;
        else if (fly_sav)
            hcount <= 0;
        else
            hcount <= hcount + 1;
    end

//
// TRS word counter
//
// The TRS word counter is used to count out the words of a TRS symbol. A
// TRS symbol for component video is four words long.
//
// During the TRS symbol the trs signal is asserted. During the XYZ word of
// a component video signal fly_xyz is asserted and one of fly_sav or fly_eav.
//
always @ (posedge clk)
    if (ce)
    begin
        if (rst | trs_next)
            trs_word <= 0;
        else
            trs_word <= trs_word + 1;
    end

always @ (posedge clk)
    if (ce)
    begin
        if (rst | clr_hcnt | fly_xyz | resync_hcnt)
            trs <= 1'b0;
        else if (trs_next)
            trs <= 1'b1;
    end
        
always @ (posedge clk)
    if (ce)
    begin
        if (rst | clr_hcnt)
            fly_xyz <= 1'b0;
        else if (trs && (trs_word == 2'b10))
            fly_xyz <= 1'b1;
        else
            fly_xyz <= 1'b0;
    end
        
assign fly_eav = fly_xyz & h;
assign fly_sav = fly_xyz & ~h;

//
// TRS location detection
//
// This block of code generates the eav_next and sav_next signals. These signals
// are asserted the state before the flywheel will generate the first word of
// the EAV or SAV TRS symbols.
//
always @ (*)
    case (std)
        NTSC_422:
            begin
                eav_loc = EAV_LOC_NTSC_422 - 1;
                sav_loc = SAV_LOC_NTSC_422 - 1;
                resync_val = EAV_LOC_NTSC_422 + 2;
            end

        NTSC_422_WIDE:
            begin
                eav_loc = EAV_LOC_NTSC_422_WIDE - 1;
                sav_loc = SAV_LOC_NTSC_422_WIDE - 1;
                resync_val = EAV_LOC_NTSC_422_WIDE + 2;
            end

        NTSC_4444:
            begin
                eav_loc = EAV_LOC_NTSC_4444 - 1;
                sav_loc = SAV_LOC_NTSC_4444 - 1;
                resync_val = EAV_LOC_NTSC_4444 + 2;
            end

        PAL_422:
            begin
                eav_loc = EAV_LOC_PAL_422 - 1;
                sav_loc = SAV_LOC_PAL_422 - 1;
                resync_val = EAV_LOC_PAL_422 + 2;
            end

        PAL_422_WIDE:
            begin
                eav_loc = EAV_LOC_PAL_422_WIDE - 1;
                sav_loc = SAV_LOC_PAL_422_WIDE - 1;
                resync_val = EAV_LOC_PAL_422_WIDE + 2;
            end

        PAL_4444:
            begin
                eav_loc = EAV_LOC_PAL_4444 - 1;
                sav_loc = SAV_LOC_PAL_4444 - 1;
                resync_val = EAV_LOC_PAL_4444 + 2;
            end

        default:
            begin
                eav_loc = EAV_LOC_NTSC_422 - 1;
                sav_loc = SAV_LOC_NTSC_422 - 1;
                resync_val = EAV_LOC_NTSC_422 + 2;
            end

    endcase

assign eav_next = (hcount == eav_loc);
assign sav_next = (hcount == sav_loc);
assign trs_next = eav_next | sav_next;

//
// h
//
// This logic generates the H bit for the TRS XYZ word. The H bit becomes
// asserted at the start of EAV and is negated at the start of SAV. Note that
// the h_blank output from the flywheel module is similar to the H bit, but 
// remains asserted until after the last word of the SAV.
//
always @ (posedge clk)
    if (ce)
    begin
        if (rst)
            h <= 1'b0;
        else if (eav_next | resync_hcnt)
            h <= 1'b1;
        else if (sav_next| clr_hcnt)
            h <= 1'b0;
    end

//
// output assignments
//
assign fly_trs = trs;
assign hcnt = hcount;

endmodule
